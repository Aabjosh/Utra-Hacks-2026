#include <Servo.h>


// Motor Driver 
int ENA = 9;   // PWM speed left motor
int IN1 = 11;
int IN2 = 8;

int ENB = 10;   // PWM speed right motor
int IN3 = 12;
int IN4 = 13;

// IR Line Sensors 
int IR_LEFT  = 2;
int IR_RIGHT = 3;

// Color Sensor 
int S0 = A0;      // Frequency scaling
int S1 = A1;      // Frequency scaling
int S2 = A2;      // Color filter select
int S3 = A3;      // Color filter select
int sensorOut = A4; // Frequency output////////////////////cahnge

// Ultrasonic Sensor 
int TRIG_PIN = 6;
int ECHO_PIN = 7;
int angle =90;

// Servos 
Servo clawServo;
Servo ultrasonicServo;  // Servo to rotate ultrasonic sensor
int CLAW_PIN = 4;
int ULTRASONIC_SERVO_PIN = 5;


void setLeftMotor(int speed, bool forward){
  analogWrite(ENA, speed);
  digitalWrite(IN1, forward);
  digitalWrite(IN2, !forward);
}

void setRightMotor(int speed, bool forward){
  analogWrite(ENB, speed);
  digitalWrite(IN3, forward);
  digitalWrite(IN4, !forward);
}

void moveForward(int spd){
  setLeftMotor(spd, true);
  setRightMotor(spd, true);
}

void moveBackward(int spd){
  setLeftMotor(spd, false);
  setRightMotor(spd, false);
}

void stopMotors(){
  setLeftMotor(0, true);
  setRightMotor(0, true);
}

void turnLeft(int spd){
  setLeftMotor(spd, false);
  setRightMotor(spd, true);
}

void turnRight(int spd){
  setLeftMotor(spd, true);
  setRightMotor(spd, false);
}

void spin180(int spd){
  setLeftMotor(spd, true);
  setRightMotor(spd, false);
  delay(1000);
  stopMotors();
}

// MH-B: LOW = black line detected, HIGH = white

void followLine(){
  if((detectColor() =="GREEN" ) || (detectColor() =="BLACK" ) || (detectColor() =="RED" ){
    turnRight(30);
  }
  else{
    turnLeft(30);
  }
}


// Function to read color frequency
int getColorFrequency(char color){
  // Set filter based on color
  if(color == 'R'){
    digitalWrite(S2, LOW);
    digitalWrite(S3, LOW);
  }
  else if(color == 'G'){
    digitalWrite(S2, HIGH);
    digitalWrite(S3, HIGH);
  }
  else if(color == 'B'){
    digitalWrite(S2, LOW);
    digitalWrite(S3, HIGH);
  }
  
  delay(100);  // Let sensor stabilize
  
  // Read frequency (lower = more of that color)
  int frequency = pulseIn(sensorOut, LOW);
  return frequency;
}

String detectColor(){
  int redFreq = getColorFrequency('R');
  int greenFreq = getColorFrequency('G');
  int blueFreq = getColorFrequency('B');
  
  
  // Check for BLACK (all frequencies high/similar)
  if(redFreq > 120 && greenFreq > 120 && blueFreq > 120){
    return "BLACK";
  }
  
  // Check for WHITE (all frequencies low/similar)
  if(redFreq < 40 && greenFreq < 40 && blueFreq < 40){
    return "WHITE";
  }
  
  // Find which color has lowest frequency (most detected)
  if(redFreq < greenFreq && redFreq < blueFreq){
    return "RED";
  }
  else if(blueFreq < redFreq && blueFreq < greenFreq){
    return "BLUE";
  }
  else if(greenFreq < redFreq && greenFreq < blueFreq){
    return "GREEN";
  }
  
  return "WHITE";  // Default
}


long getDistance(){
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  
  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  
  if(duration == 0) return 999; // No echo received
  
  return duration * 0.034 / 2;
}

// Scan for obstacles by rotating ultrasonic sensor
long scanForObstacle(){
  long minDistance = 999;
  
  // Scan left
  ultrasonicServo.write(135);
  delay(200);
  long leftDist = getDistance();
  if(leftDist < minDistance) minDistance = leftDist;
  
  // Scan center
  ultrasonicServo.write(90);
  delay(200);
  long centerDist = getDistance();
  if(centerDist < minDistance) minDistance = centerDist;
  
  // Scan right
  ultrasonicServo.write(45);
  delay(200);
  long rightDist = getDistance();
  if(rightDist < minDistance) minDistance = rightDist;
  
  // Return to center
  ultrasonicServo.write(90);
  delay(200);
  
  return minDistance;
}


void dropBox(){
  stopMotors();
  turnRight(30);
  delay(1000);
  stopMotors();
  moveForward(30);
  delay(300);
  clawServo.write(30);   // open claw
  delay(800);
  moveBackward(30);
  delay(300);
  turnLeft(90);
  delay(1000);

}

void getBox(){
  stopMotors();
  turnLeft(30);
  delay(1000);
  stopMotors();
  moveForward(30);
  delay(300);
  clawServo.write(0);   // close claw
  delay(800);
  moveBackward(30);
  delay(300);
  turnRight(90);
  delay(1000);
}

void goToTargetCenter(){
  while(detectColor() != "BLACK"){
    moveForward(10);
  }
  stopMotors();
  delay(400);
}

void obstacleCourse(){
  while(true){
    long d = getDistance();

    if(d < 15){
      // Scan to find best path
      stopMotors();
      delay(100);
      scanForObstacle();
      
      turnRight(130);
      delay(350);
    } else {
      followLine();
    }

    if(detectColor() == "WHITE") break;
  }
}

void setup(){
  pinMode(IN1, OUTPUT); 
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT); 
  pinMode(IN4, OUTPUT);
  pinMode(ENA, OUTPUT); 
  pinMode(ENB, OUTPUT);

  pinMode(IR_LEFT, INPUT);
  pinMode(IR_RIGHT, INPUT);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // TCS3200 setup
  pinMode(S0, OUTPUT);
  pinMode(S1, OUTPUT);
  pinMode(S2, OUTPUT);
  pinMode(S3, OUTPUT);
  pinMode(sensorOut, INPUT);
  
  // Set frequency scaling to 20%
  digitalWrite(S0, HIGH);
  digitalWrite(S1, LOW);

  clawServo.attach(CLAW_PIN);
  ultrasonicServo.attach(ULTRASONIC_SERVO_PIN);
  
  clawServo.write(30);    // closed
  ultrasonicServo.write(angle); // center position
  delay(500);
}


void loop(){
  
  // Detect path split (green/red)
  // Move to BLUE zone to drop box
  while(detectColor() != "BLUE"){
    followLine();
  }


  getBox();

  dropBox();
  goToTargetCenter();
  clawServo.write(0);   // close claw
  delay(1000);
  while(detectColor() != "BLUE"){
    moveForward(10);
    delay(50);
  }
  stopMotors();
  clawServo.write(120);   // close claw
  moveBackward(50);
  delay(400);
  spin180(50);
  moveForward(30);
  while(detectColor() != "BLACK"){
    delay(50);
  }
  stopMotors();
  while(detectColor() != "BLUE"){
    followLine();
  }
  getBox();
  while(getDistance()>10){
    followLine();
  }
  turnRight(30);
  delay(300);
  moveForward(30);
  delay(300);
  stopMotors();
  while(getDistance()>20){
    angle--;
    ultrasonicServo.write(angle);
    delay(100);
  }
  while((digitalRead(IR_RIGHT)==LOW) && (digitalRead(IR_LEFT)==LOW)){
    if(getDistance()<=10){
      turnRight(30);
    }
    else{
      turnLeft(30);
    }
  }
  angle = 90;
  ultrasonicServo.write(angle);
  delay(300);

  while(getDistance()>10){
    followLine();
  }
  turnRight(30);
  delay(300);
  moveForward(30);
  delay(300);
  stopMotors();
  while(getDistance()>20){
    angle--;
    ultrasonicServo.write(angle);
    delay(100);
  }
  while((digitalRead(IR_RIGHT)==LOW) && (digitalRead(IR_LEFT)==LOW)){
    if(getDistance()<=10){
      turnRight(30);
    }
    else{
      turnLeft(30);
    }
  }
  angle = 90;
  ultrasonicServo.write(angle);
  delay(300);

  while(detectColor() != "BLUE"){
    followLine();
  }
  dropBox();
  while(detectColor() != "BLACK"){
    followLine();
  }

  stopMotors();
}
